// PPFS.cpp automatically generated by bin/add_new_algorithm.pl
// in Tue Oct 24 19:26:08 2017.

//
// PPFS.cpp -- implementation of the class "PPFS".
//
//    This file is part of the featsel program
//    Copyright (C) 2016  Marcelo S. Reis
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#include "PPFS.h"


PPFS::PPFS ()
{
  list_of_visited_subsets = new Collection ();
  cost_function = NULL;
  bound = FLT_MAX;
  min_list_ptr = &list_of_minima;
}


PPFS::~PPFS ()
{
  if (list_of_visited_subsets != NULL)
  delete list_of_visited_subsets;
}


void PPFS::get_minima_list (unsigned int max_size_of_minima_list)
{
  timeval begin_program, end_program;
  gettimeofday (& begin_program, NULL);

  //
  unsigned int direction;
  ForestMap Forest_A, Forest_B;
  PFSNode * N;

  // the spanning tree T
  N = new PFSNode;
  N->vertex = new ElementSubset ("", set);
  store_visited_subset (N->vertex);
  N->adjacent = new ElementSubset ("", set);
  N->adjacent->set_complete_subset ();
  N->leftmost = 0;  // the first index is zero
  N->cost = FLT_MAX;
  N->vertex->cost = FLT_MAX;
  Forest_A.insert (pair<string, PFSNode *> (N->vertex->print_subset (), N));

  // the spanning tree T'
  N = new PFSNode;
  N->vertex = new ElementSubset ("", set);
  N->vertex->set_complete_subset ();
  store_visited_subset (N->vertex);
  N->adjacent = new ElementSubset ("", set);
  N->adjacent->set_complete_subset ();
  N->leftmost = 0;  // the first index is zero
  N->cost = FLT_MAX;
  N->vertex->cost = FLT_MAX;
  Forest_B.insert (pair<string, PFSNode *> (N->vertex->print_subset (), N));

  nof_processors = omp_get_num_procs ();

  srand ( (unsigned) time (NULL) );
  while ( ( (Forest_A.size () > 0) && (Forest_B.size () > 0) ) &&
        (! cost_function->has_reached_threshold ()) )
  {
    direction = rand () % 2;
    number_of_iterations++;

    cout << "\n\nDirection = " << direction << endl;

    if (direction == 0)
      lower_forest_iteration (&Forest_A, &Forest_B);
    else
      upper_forest_iteration (&Forest_A, &Forest_B);
  }
  //

  number_of_visited_subsets =
  cost_function->get_number_of_calls_of_cost_function ();
  clean_list_of_minima (max_size_of_minima_list);
  gettimeofday (& end_program, NULL);
  elapsed_time_of_the_algorithm = diff_us (end_program, begin_program);
}


void PPFS::lower_forest_iteration (ForestMap * Forest_A, 
  ForestMap * Forest_B)
{
  #pragma omp parallel
  {
    PFSNode * N;
    N = lower_forest_branch (Forest_A, Forest_B);
    
    if (N != NULL)
    {
      if (! cost_function->has_reached_threshold ())
        upper_forest_pruning (Forest_B, N);

      #pragma omp critical
      cout << "lower_forest_iteration is deleting " << N->vertex->print_subset () << endl;
      delete N->vertex;
      delete N->adjacent;
      delete N;
    }
    #pragma omp critical
    cout << "Thread " << omp_get_thread_num () << " exiting!" << endl;
  }
  cout << "Batch finished!!" << endl;
}


void PPFS::upper_forest_iteration (ForestMap * Forest_A, 
  ForestMap * Forest_B)
{
  PFSNode * N;
  N = upper_forest_branch (Forest_A, Forest_B);

  if (N != NULL)
  {
    if (! cost_function->has_reached_threshold ())
      lower_forest_pruning (Forest_A, N);

    #pragma omp critical
    cout << "upper_forest_iteration is deleting " << N->vertex->print_subset () << endl;
    delete N->vertex;
    delete N->adjacent;
    delete N;
  }
}


PFSNode * PPFS::lower_forest_branch (ForestMap * Forest_A, 
  ForestMap * Forest_B)
{
  ForestMap::iterator it;
  PFSNode * R, * M, * N;
  unsigned int i, m;

  #pragma omp critical
  {
    if (Forest_A->size () == 0)
      R = NULL;
    else
    {
      unsigned int tid = omp_get_thread_num ();
      // cout << "Thread " << tid << " wants a tree to branch on " << endl;
      i = rand () % 2;
      if (i == 0)
        it = Forest_A->begin ();
      else
      {
        it = Forest_A->end ();
        it--;
      }

      R = it->second;         // selects a tree from the forest
      cout << "Thread " << tid << " selected " << R->vertex->print_subset () << endl;
      Forest_A->erase (it);
    }
  }
  #pragma omp barrier

  if (R == NULL)
    return NULL;

  calculate_node_cost (R, Forest_B);
  M = R;
  N = R;

  // Walk on the tree whose root is R[vertex]
  //
  while (!N->adjacent->is_empty () && N->cost <= M->cost)
  {
    #pragma omp critical
    Forest_A->insert (pair<string, PFSNode *> (N->vertex->print_subset (), N));

    M = N;
    m = M->adjacent->remove_random_element ();
    N = new PFSNode;
    N->vertex = new ElementSubset ("", set);
    N->vertex->copy (M->vertex);
    N->vertex->add_element (m);

    #pragma omp critical
    store_visited_subset (N->vertex);

    N->leftmost = m + 1;  // the index starts with zero
    N->adjacent = new ElementSubset ("", set);
    N->cost = FLT_MAX;
    for (i = N->leftmost; i < set->get_set_cardinality (); i++)
      N->adjacent->add_element (i);
    calculate_node_cost (N, Forest_B);

    if (N->cost <= M->cost)
    {
      N->vertex->cost = N->cost;
      parallel_store_minimum_subset (N->vertex);
    }

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    if (cost_function->has_reached_threshold ())
      return N;
  }

  return N;
}


PFSNode * PPFS::upper_forest_branch (ForestMap * Forest_A, 
  ForestMap * Forest_B)
{
  ForestMap::iterator it;
  PFSNode * R, * M, * N;
  unsigned int i, m;

  #pragma omp critical
  {
    if (Forest_B->size () == 0)
      R = NULL;
    else
    {
      unsigned int tid = omp_get_thread_num ();
      i = rand () % 2;
      if (i == 0)
        it = Forest_B->begin ();
      else
      {
        it = Forest_B->end ();
        it--;
      }

      R = it->second;         // selects a tree from the forest
      cout << "Thread " << omp_get_thread_num () << " selected " << R->vertex->print_subset () << endl;
      Forest_B->erase (it);
    }
  }
  #pragma omp barrier

  if (R == NULL)
    return NULL;

  calculate_node_cost (R, Forest_A);
  M = R;
  N = R;

  // Walk on the tree whose root is R[vertex]
  //
  while (!N->adjacent->is_empty () && N->cost <= M->cost)
  {
    #pragma omp critical
    Forest_B->insert (pair<string, PFSNode *> (N->vertex->print_subset (), N));

    M = N;
    m = M->adjacent->remove_random_element ();
    N = new PFSNode;
    N->vertex = new ElementSubset ("", set);
    N->vertex->copy (M->vertex);
    N->vertex->remove_element (m);

    #pragma omp critical
    store_visited_subset (N->vertex);

    N->leftmost = m + 1;  // the index starts with zero
    N->adjacent = new ElementSubset ("", set);
    N->cost = FLT_MAX;
    for (i = N->leftmost; i < set->get_set_cardinality (); i++)
      N->adjacent->add_element (i);
    calculate_node_cost (N, Forest_A);

    if (N->cost <= M->cost)
    {
      N->vertex->cost = N->cost;
      parallel_store_minimum_subset (N->vertex);
    }

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    if (cost_function->has_reached_threshold ())
      return N;
  }

  return N;
}


void PPFS::search_upper_root (ForestMap * Forest_B, 
  ElementSubset * M)
{
  ForestMap::iterator it;
  PFSNode * N;
  unsigned int i;
  int m, k = set->get_set_cardinality () - 1;

  while ((k >= 0) && (M->has_element ((unsigned int) k)) )
    k--;

  while (k >= 0)
  {
    M->add_element (k);
    #pragma omp critical
    it = Forest_B->find (M->print_subset ());
    if (it != Forest_B->end ())
    {
      it->second->adjacent->remove_element (k);
      k = -1;
    }
    else
    {
      N = new PFSNode;
      N->vertex = new ElementSubset ("", set);
      N->vertex->copy (M);
      #pragma omp critical
      store_visited_subset (N->vertex);

      m = k;
      while ((k >= 0) && (M->has_element ((unsigned int) k)) )
        k--;
      N->leftmost = k + 1;  // the index starts with zero

      N->adjacent = new ElementSubset ("", set);
      for (i = N->leftmost; i < set->get_set_cardinality (); i++)
        N->adjacent->add_element (i);
      N->adjacent->remove_element ((unsigned int) m);
      N->cost = FLT_MAX; // infinity

      #pragma omp critical
      Forest_B->insert (pair<string, PFSNode *> (N->vertex->print_subset (), N));

      // if the algorithm is working under heuristic mode 1 or 2
      // and has reached threshold, then the search is stopped.
      if (cost_function->has_reached_threshold ())
        return;
    } // else
  } // while
}


void PPFS::search_lower_root (ForestMap * Forest_A, 
  ElementSubset * M)
{
  ForestMap::iterator it;
  PFSNode * N;
  unsigned int i;
  int m, k = set->get_set_cardinality () - 1;

  while ((k >= 0) && (! M->has_element ((unsigned int) k)) )
    k--;

  while (k >= 0)
  {
    M->remove_element (k);
    #pragma omp critical
    it = Forest_A->find (M->print_subset ());
    if (it != Forest_A->end ())
    {
      it->second->adjacent->remove_element (k);
      k = -1;
    }
    else
    {
      N = new PFSNode;
      N->vertex = new ElementSubset ("", set);
      N->vertex->copy (M);
      #pragma omp critical
      store_visited_subset (N->vertex);

      m = k;
      while ((k >= 0) && (! M->has_element ((unsigned int) k)) )
        k--;
      N->leftmost = k + 1;  // the index starts with zero
      N->adjacent = new ElementSubset ("", set);
      for (i = N->leftmost; i < set->get_set_cardinality (); i++)
        N->adjacent->add_element (i);
      N->adjacent->remove_element ((unsigned int) m);
      N->cost = FLT_MAX; // infinity

      #pragma omp critical
      Forest_A->insert (pair<string, PFSNode *> (N->vertex->print_subset (), N));

      // if the algorithm is working under heuristic mode 1 or 2
      // and has reached threshold, then the search is stopped.
      if (cost_function->has_reached_threshold ())
        return;
    } // else
  } // while
}


void PPFS::search_lower_children (ForestMap * Forest_B, PFSNode * N, 
  ElementSubset * M, ElementSubset * Y)
{
  ForestMap::iterator it;
  int i;
  PFSNode * B;
  unsigned int j;

  i = set->get_set_cardinality () - 1;  // i = n
  while ((i >= 0) && (M->has_element (i)) )
  {
    M->remove_element (i); // A = M - {s_i}

    if (M->contains (Y)) // if B contains Y
    {
      #pragma omp critical
      {
        it = Forest_B->find (M->print_subset ());
        if (it != Forest_B->end ())
        {
          cout << "search_lower_children is deleting " << N->vertex->print_subset () << endl;
          delete it->second->vertex;
          delete it->second->adjacent;
          delete it->second;
          Forest_B->erase (it);
        }
      }
    }
    else
    {
      if (((N == NULL) || (N->adjacent->has_element (i)) ) )
      {
        B = new PFSNode;
        B->vertex = new ElementSubset ("", set);
        B->vertex->copy (M);
        #pragma omp critical
        store_visited_subset (B->vertex);

        B->leftmost = i + 1;  // the index starts with zero
        B->adjacent = new ElementSubset ("", set);
        for (j = B->leftmost; j < set->get_set_cardinality (); j++)
          B->adjacent->add_element (j);

        B->cost = FLT_MAX; // infinity

        #pragma omp critical
        Forest_B->insert(pair<string, PFSNode *> (B->vertex->print_subset (), B));

        // if the algorithm is working under heuristic mode 1 or 2
        // and has reached threshold, then the search is stopped.
        if (cost_function->has_reached_threshold ())
          return;
      } // if ((it == Forest_A->end ()) &&
    } // else
    M->add_element (i);
    i--;
  } // while (i..
}


void PPFS::search_upper_children (ForestMap * Forest_A, PFSNode * N, 
  ElementSubset * M, ElementSubset * Y)
{
  ForestMap::iterator it;
  int i;
  PFSNode * A;
  unsigned int j;

  i = set->get_set_cardinality () - 1;  // i = n
  while ((i >= 0) && (! M->has_element (i)) )
  {
    M->add_element (i); // A = M \cup {s_i}

    if (M->is_contained_by (Y) ) // if A is contained in Y
    {
      #pragma omp critical
      {
        it = Forest_A->find (M->print_subset ());
        if (it != Forest_A->end ())
        {
          cout << "search_upper_children is deleting " << N->vertex->print_subset () << endl;
          delete it->second->vertex;
          delete it->second->adjacent;
          delete it->second;
          Forest_A->erase (it);
        }
      }
    }
    else
    {
      if (N == NULL || N->adjacent->has_element (i))
      {
        A = new PFSNode;
        A->vertex = new ElementSubset ("", set);
        A->vertex->copy (M);
        #pragma omp critical
        store_visited_subset (A->vertex);

        A->leftmost = i + 1;  // the index starts with zero
        A->adjacent = new ElementSubset ("", set);
        for (j = A->leftmost; j < set->get_set_cardinality (); j++)
          A->adjacent->add_element (j);
        A->cost = FLT_MAX; // infinity

        #pragma omp critical
        Forest_A->insert(pair<string, PFSNode *> (A->vertex->print_subset (), A));

        // if the algorithm is working under heuristic mode 1 or 2
        // and has reached threshold, then the search is stopped.
        if (cost_function->has_reached_threshold ())
          return;
      } // if ((it == Forest_A->end ()) &&
    } // else
    M->remove_element (i);
    i--;
  } // while (i..
}


void PPFS::upper_forest_pruning (ForestMap * Forest_B, PFSNode * N)
{
  ForestMap::iterator it;
  PFSNode * _M;
  ElementSubset M ("", set);
  int k;

  M.copy (N->vertex);
  k = set->get_set_cardinality () - 1;  // k = n - 1

  while (!N->adjacent->is_empty () && k >= (int) N->leftmost)
  {
    #pragma omp critical
    {
      it  = Forest_B->find (M.print_subset ());
      if (it != Forest_B->end ())
      {
        _M = it->second;
        Forest_B->erase (it);
      }
      else
        _M = NULL;
    }
    search_lower_children (Forest_B, _M, & M, N->vertex);

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    if (cost_function->has_reached_threshold ())
      return;

    if (_M != NULL)
    {
      #pragma omp critical
          cout << "upper_forest_pruning is deleting " << N->vertex->print_subset () << endl;
      delete _M->vertex;
      delete _M->adjacent;
      delete _M;
    }

    M.add_element (k);
    k--;
  }

  #pragma omp critical
  it  = Forest_B->find (M.print_subset ());
  if (it != Forest_B->end ())
  {
    search_lower_children (Forest_B, it->second, & M, N->vertex);

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    //
    if (cost_function->has_reached_threshold ())
      return;
    
    #pragma omp critical
    {
      it  = Forest_B->find (M.print_subset ());
          cout << "upper_forest_pruning is deleting " << N->vertex->print_subset () << endl;
      delete it->second->vertex;
      delete it->second->adjacent;
      delete it->second;
      Forest_B->erase (it);
    }
  }
  else
  {
    search_lower_children (Forest_B, NULL, &M, N->vertex);

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    //
    if (cost_function->has_reached_threshold ())
      return;

    search_upper_root (Forest_B, &M); // warning: this function modifies "M" !!!

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    //
    if (cost_function->has_reached_threshold ())
      return;
  }
}


void PPFS::lower_forest_pruning (ForestMap * Forest_A, PFSNode * N)
{
  ForestMap::iterator it;
  PFSNode * _M;
  ElementSubset M ("", set);
  int k;

  M.copy (N->vertex);
  k = set->get_set_cardinality () - 1;  // k = n - 1

  while ((! N->adjacent->is_empty ()) && (k >= (int) N->leftmost) )
  {
    #pragma omp critical
    {
      it  = Forest_A->find (M.print_subset ());
      if (it != Forest_A->end ())
      {
        _M = it->second;
        Forest_A->erase (it);
      }
      else
        _M = NULL;
    }
    search_upper_children (Forest_A, _M, & M, N->vertex);

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    if (cost_function->has_reached_threshold ())
      return;

    if (_M != NULL)
    {

      #pragma omp critical
          cout << "lower_forest_pruning is deleting " << N->vertex->print_subset () << endl;
      delete _M->vertex;
      delete _M->adjacent;
      delete _M;
    }

    M.remove_element (k);
    k--;
  }

  #pragma omp critical
  it  = Forest_A->find (M.print_subset ());
  if (it != Forest_A->end ())
  {
    search_upper_children (Forest_A, it->second, & M, N->vertex);

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    //
    if (cost_function->has_reached_threshold ())
      return;

    #pragma omp critical
    {
      it = Forest_A->find (M.print_subset ());
          cout << "lower_forest_pruning is deleting " << N->vertex->print_subset () << endl;
      delete it->second->vertex;
      delete it->second->adjacent;
      delete it->second;
      Forest_A->erase (it);
    }
  }
  else
  {
    search_upper_children (Forest_A, NULL, &M, N->vertex);

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    //
    if (cost_function->has_reached_threshold ())
      return;

    search_lower_root (Forest_A, & M); // warning: this function modifies "M" !!!

    // if the algorithm is working under heuristic mode 1 or 2
    // and has reached threshold, then the search is stopped.
    //
    if (cost_function->has_reached_threshold ())
      return;
  }
}

void PPFS::calculate_node_cost (PFSNode * R, ForestMap * Forest_Dual)
{
  if (R->cost != FLT_MAX)
    return;
  
  PFSNode * RB = NULL;
  ForestMap::iterator it; 
  

  #pragma omp critical
  it = Forest_Dual->find (R->vertex->print_subset ());
  if (it == Forest_Dual->end ())
  {
    R->cost = cost_function->cost (R->vertex);
    R->vertex->cost = R->cost;
    parallel_store_minimum_subset (R->vertex);
  }
  else
  {
    RB = it->second;
    if (RB->cost == FLT_MAX)
    {
      R->cost = cost_function->cost (R->vertex);
      R->vertex->cost = R->cost;
      RB->cost = R->cost;
      RB->vertex->cost = RB->cost;
      parallel_store_minimum_subset (R->vertex);
    }
    else
    {
      R->cost = RB->cost;
      R->vertex->cost = R->cost;
    } 
  }
}


void PPFS::parallel_store_minimum_subset (ElementSubset * X)
{
  ElementSubset * Y;
  Y = new ElementSubset ("", set);
  Y->copy (X);
  min_list_ptr->push_back (Y);
}
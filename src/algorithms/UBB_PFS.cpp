// UBB_PFS.cpp automatically generated by bin/add_new_algorithm.pl
// in Mon Nov 13 08:04:37 2017.

//
// UBB_PFS.cpp -- implementation of the class "UBB_PFS".
//
//    This file is part of the featsel program
//    Copyright (C) 2016  Gustavo Estrela, Marcelo S. Reis
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#include "UBB_PFS.h"
#include "PosetForestSearch.h"
#include "../functions/PartCost.h"

UBB_PFS::UBB_PFS ()
{
  list_of_visited_subsets = new Collection ();
  cost_function = NULL;
  max_size_of_minima_list = 1;
}


UBB_PFS::~UBB_PFS ()
{
  if (list_of_visited_subsets != NULL)
  delete list_of_visited_subsets;
}


void UBB_PFS::get_minima_list (unsigned int max_size_of_minima_list)
{
  timeval begin_program, end_program;
  gettimeofday (& begin_program, NULL);

  this->max_size_of_minima_list = max_size_of_minima_list;

  ElementSubset * A, * B;
  unsigned int i, n;
  double bound, current_cost, last_cost;
  list <ElementSubset *> Stack;
  list <unsigned int> Leftmost_free_elem;
  list <double> Last_cost_stack;

  A = new ElementSubset ("A", set);
  Stack.push_back (A);
  Leftmost_free_elem.push_back (0);
  Last_cost_stack.push_back (INFTY);
  bound = INFTY;

  while ((! Stack.empty ()) && (! cost_function->has_reached_threshold ()))
  {
    A = Stack.back ();
    Stack.pop_back ();
    n = Leftmost_free_elem.back ();
    Leftmost_free_elem.pop_back ();
    last_cost = Last_cost_stack.back ();
    Last_cost_stack.pop_back ();

    // cout << "Current element_subset " << A->print_subset () << endl;

    current_cost = A->cost = cost_function->cost (A);

    if (A->get_subset_cardinality () == 0 || current_cost <= last_cost)
    {
      // The bound helps to keep the list of minimum small
      //
      if (current_cost <= bound)
      {
        bound = current_cost;
        B = new ElementSubset ("", set);
        B->copy (A);
        list_of_minima.push_back (B);
      }

      if (store_visited_subsets)
        list_of_visited_subsets->add_subset (A);

      for (i = n; i < set->get_set_cardinality (); i++)
      {
        A->add_element (i);
        B = new ElementSubset ("", set);
        B->copy (A);
        Stack.push_back (B);
        Leftmost_free_elem.push_back (i+1);
        Last_cost_stack.push_back (current_cost);
        A->remove_element (i);
        // cout << "Stacked " << B->print_subset () << endl;
      }
    } // if

    // if (Stack.size () >= omp_get_num_threads ())
    if (Stack.size () >= 7)
    {
      parallel_solve (&Stack, &Leftmost_free_elem);
    }

    delete A;
  } // while

  number_of_visited_subsets =
  cost_function->get_number_of_calls_of_cost_function ();

  clean_list_of_minima (max_size_of_minima_list);

  gettimeofday (& end_program, NULL);
  elapsed_time_of_the_algorithm =
  diff_us (end_program, begin_program);
}


void UBB_PFS::parallel_solve (list<ElementSubset *> * S, 
  list<unsigned int> * S_leftmost)
{
  ElementSubset * X;
  unsigned int leftmost;
  

  #pragma omp parallel
  #pragma omp single nowait
  {
    while (!S->empty ())
    {
      Partition * partition;
      ElementSet * fixed_set;
      ElementSet * unfixed_set;
      ElementSubset * fixed_subset;

      X = S->back ();
      leftmost = S_leftmost->back ();
      S->pop_back ();
      S_leftmost->pop_back ();

      if (leftmost == set->get_set_cardinality ())
      {
        #pragma omp critical
        X->cost = cost_function->cost (X);
        store_minimum_subset (X);
        // cout << X->print_subset () << " has empty subtree " << endl;
        delete X;
        continue;
      }
      
      // cout << "Solving from: " << X->print_subset () << endl;
      partition = set_partition (leftmost);
      fixed_set = partition->get_fixed_elm_set ();
      unfixed_set = partition->get_unfixed_elm_set ();

      fixed_subset = new ElementSubset ("", fixed_set);
      for (unsigned int i = 0; i < fixed_set->get_set_cardinality (); i++)
        if (X->has_element (i))
          fixed_subset->add_element (i);
      delete X;

      PartitionNode * P = new PartitionNode (partition, fixed_subset);
      PartCost * part_cost = new PartCost (cost_function, P);

      #pragma omp task
      {
        Solver * sub_solver;
        sub_solver = new PosetForestSearch ();
        sub_solver->set_parameters (part_cost, unfixed_set, 
          store_visited_subsets);
        solve_part (sub_solver, P);
        delete partition;
        delete fixed_subset;
        delete P;
        delete part_cost;
        delete sub_solver; 
      }
    }
  }
  #pragma omp taskwait
}


void UBB_PFS::solve_part (Solver * sub_solver, PartitionNode * P)
{
  Collection * visited_subsets;
  list<ElementSubset *> part_min_list;

  sub_solver->get_minima_list (max_size_of_minima_list);
  part_min_list = sub_solver->get_list_of_minima ();
  while (part_min_list.size () > 0) 
  {
    ElementSubset * pX = part_min_list.back ();
    part_min_list.pop_back ();
    ElementSubset * X = P->get_original_subset (pX);
    X->cost = pX->cost;
    #pragma omp critical
    store_minimum_subset (X);
    delete X;
    delete pX;
  }

  visited_subsets = sub_solver->get_list_of_visited_subsets ();
  update_visited_subsets (visited_subsets, P);
}


void UBB_PFS::update_visited_subsets (Collection * T, PartitionNode * P)
{
  while (T->size () > 0) 
  {
    ElementSubset * pX = T->remove_last_subset ();
    ElementSubset * X = P->get_original_subset (pX);
    #pragma omp critical
    store_visited_subset (X);
    delete pX;
    delete X;
  }
}



Partition * UBB_PFS::set_partition (unsigned int l)
{ 
  unsigned int set_card = set->get_set_cardinality ();
  bool * is_fixed = new bool[set_card];
  Partition * partition;

  for (unsigned int i = 0; i < set_card; i++)
    is_fixed[i] = i < l;

  partition = new Partition (set, is_fixed);
  delete[] is_fixed;
  return partition;
}